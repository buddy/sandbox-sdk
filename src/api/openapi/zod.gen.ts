// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

export const zUriBuilder = z.record(z.string(), z.unknown());

export const zStatusType = z.object({
	family: z.optional(
		z.enum([
			"INFORMATIONAL",
			"SUCCESSFUL",
			"REDIRECTION",
			"CLIENT_ERROR",
			"SERVER_ERROR",
			"OTHER",
		]),
	),
	status_code: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			}),
	),
	reason_phrase: z.optional(z.string()),
});

export const zEntityTag = z.object({
	value: z.optional(z.string()),
	weak: z.optional(z.boolean()),
});

export const zMediaType = z.object({
	type: z.optional(z.string()),
	subtype: z.optional(z.string()),
	parameters: z.optional(z.record(z.string(), z.string())),
	wildcard_type: z.optional(z.boolean()),
	wildcard_subtype: z.optional(z.boolean()),
});

export const zLink = z.object({
	uri: z.optional(z.url()),
	uri_builder: z.optional(zUriBuilder),
	rel: z.optional(z.string()),
	rels: z.optional(z.array(z.string())),
	type: z.optional(z.string()),
	params: z.optional(z.record(z.string(), z.string())),
	title: z.optional(z.string()),
});

export const zNewCookie = z.object({
	name: z.optional(z.string()),
	value: z.optional(z.string()),
	version: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			}),
	),
	path: z.optional(z.string()),
	domain: z.optional(z.string()),
	comment: z.optional(z.string()),
	max_age: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			}),
	),
	expiry: z.optional(z.iso.datetime()),
	secure: z.optional(z.boolean()),
	http_only: z.optional(z.boolean()),
	same_site: z.optional(z.enum(["NONE", "LAX", "STRICT"])),
});

export const zResponse = z.object({
	status_info: z.optional(zStatusType),
	allowed_methods: z.optional(z.array(z.string())),
	cookies: z.optional(z.record(z.string(), zNewCookie)),
	links: z.optional(z.array(zLink)),
	media_type: z.optional(zMediaType),
	entity_tag: z.optional(zEntityTag),
	string_headers: z.optional(
		z.object({
			empty: z.optional(z.boolean()),
		}),
	),
	closed: z.optional(z.boolean()),
	length: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			}),
	),
	location: z.optional(z.url()),
	language: z.optional(
		z.object({
			language: z.optional(z.string()),
			display_name: z.optional(z.string()),
			country: z.optional(z.string()),
			variant: z.optional(z.string()),
			script: z.optional(z.string()),
			unicode_locale_attributes: z.optional(z.array(z.string())),
			unicode_locale_keys: z.optional(z.array(z.string())),
			display_language: z.optional(z.string()),
			display_script: z.optional(z.string()),
			display_country: z.optional(z.string()),
			display_variant: z.optional(z.string()),
			extension_keys: z.optional(z.array(z.string())),
			iso3_language: z.optional(z.string()),
			iso3_country: z.optional(z.string()),
		}),
	),
	date: z.optional(z.iso.datetime()),
	last_modified: z.optional(z.iso.datetime()),
	status: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			}),
	),
	metadata: z.optional(
		z.object({
			empty: z.optional(z.boolean()),
		}),
	),
	entity: z.optional(z.record(z.string(), z.unknown())),
	headers: z.optional(
		z.object({
			empty: z.optional(z.boolean()),
		}),
	),
});

/**
 * Sandbox reference
 */
export const zSandboxIdView = z
	.object({
		url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "API endpoint to GET this object",
				})
				.readonly(),
		),
		html_url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "Web URL to view this object in Buddy.works",
				})
				.readonly(),
		),
		id: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The ID of the sandbox",
			}),
		),
		identifier: z.optional(
			z.string().register(z.globalRegistry, {
				description:
					"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
			}),
		),
		name: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The name of the sandbox",
			}),
		),
		status: z.optional(
			z
				.enum([
					"STARTING",
					"STOPPING",
					"FAILED",
					"RUNNING",
					"STOPPED",
					"RESTORING",
				])
				.register(z.globalRegistry, {
					description: "The current status of the sandbox",
				}),
		),
	})
	.register(z.globalRegistry, {
		description: "Sandbox reference",
	});

/**
 * Integration reference
 */
export const zIntegrationIdView = z
	.object({
		url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "API endpoint to GET this object",
				})
				.readonly(),
		),
		html_url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "Web URL to view this object in Buddy.works",
				})
				.readonly(),
		),
		identifier: z.optional(
			z.string().register(z.globalRegistry, {
				description: "A human-readable ID of the integration",
			}),
		),
		hash_id: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The unique hash ID of the integration",
			}),
		),
		name: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The name of the integration",
			}),
		),
		type: z.optional(
			z
				.enum([
					"GIT_HUB",
					"BITBUCKET",
					"GOOGLE",
					"DIGITAL_OCEAN",
					"SLACK",
					"MODULUS",
					"HEROKU",
					"AMAZON",
					"GIT_LAB",
					"SHOPIFY",
					"GIT_HUB_ENTERPRISE",
					"GIT_LAB_ENTERPRISE",
					"PUSHOVER",
					"PUSHBULLET",
					"RACKSPACE",
					"CUSTOM",
					"CLOUDFLARE",
					"NEW_RELIC",
					"SENTRY",
					"ROLLBAR",
					"DATADOG",
					"DO_SPACES",
					"HONEYBADGER",
					"VULTR",
					"SENTRY_ENTERPRISE",
					"LOGGLY",
					"HIP_CHAT",
					"FIREBASE",
					"TELEGRAM",
					"AZURE",
					"UPCLOUD",
					"GHOST_INSPECTOR",
					"NETLIFY",
					"AZURE_CLOUD",
					"MICROSOFT_TEAMS",
					"GOOGLE_SERVICE_ACCOUNT",
					"GOOGLE_PLAY_STORE",
					"DOCKER_HUB",
					"APP_STORE",
					"GIT_HUB_APP",
					"GIT_HUB_APP_ENTERPRISE",
					"GIT_HUB_API",
					"ATOP",
					"SNYK",
					"STACK_HAWK",
					"BLACKFIRE",
					"BACKBLAZE",
					"ONE_LOGIN",
					"OKTA",
					"CONTENTFUL",
				])
				.register(z.globalRegistry, {
					description: "The type of integration",
				}),
		),
		auth_type: z.optional(
			z
				.enum([
					"OAUTH",
					"TOKEN",
					"API_KEY",
					"APP",
					"APP_SPRYKER",
					"TOKEN_APP_EXTENSION",
					"DEFAULT",
					"OIDC",
					"TRUSTED",
					"APP_RW",
				])
				.register(z.globalRegistry, {
					description: "The authentication method used by the integration",
				}),
		),
		host_url: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The host URL for custom integrations",
			}),
		),
		webhook_address: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The webhook URL for receiving notifications",
			}),
		),
		atop_url: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The ATOP service URL",
			}),
		),
		app_id: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The application ID for Azure Cloud integrations",
			}),
		),
		google_project: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The Google Cloud project ID",
			}),
		),
		audience: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The JWT audience for token validation",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Integration reference",
	});

/**
 * User/member reference
 */
export const zMemberView = z
	.object({
		url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "API endpoint to GET this object",
				})
				.readonly(),
		),
		html_url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "Web URL to view this object in Buddy.works",
				})
				.readonly(),
		),
		id: z.optional(
			z
				.int()
				.min(-2147483648, {
					error: "Invalid value: Expected int32 to be >= -2147483648",
				})
				.max(2147483647, {
					error: "Invalid value: Expected int32 to be <= 2147483647",
				})
				.register(z.globalRegistry, {
					description: "The ID of the user",
				}),
		),
		name: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The name of the user",
			}),
		),
		avatar_url: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The avatar URL of the user",
			}),
		),
		email: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The email address of the user",
			}),
		),
		admin: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether the user has admin privileges",
			}),
		),
		workspace_owner: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether the user is workspace owner",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "User/member reference",
	});

export const zProjectView = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the project",
		}),
	),
	display_name: z.string().register(z.globalRegistry, {
		description: "The Name of the project",
	}),
	status: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The status of the project",
		}),
	),
	access: z.optional(
		z.enum(["PRIVATE", "PUBLIC"]).register(z.globalRegistry, {
			description: "Indicates if this is a public project",
		}),
	),
	create_date: z.optional(
		z.iso.datetime().register(z.globalRegistry, {
			description: "The creation date of the project",
		}),
	),
	external_project_id: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"Repo slug of the Bitbucket, GitHub or GitLab project. Required when adding the integrated project",
		}),
	),
	git_lab_project_id: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description: "ID of the project in GitLab",
			}),
	),
	custom_repo_url: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"SSH or HTTPS url of the git repository. Required when adding the project integrated with custom git repository",
		}),
	),
	custom_repo_user: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"Username used to authorize access to the git repository. Required when adding the project integrated with custom git repository",
		}),
	),
	custom_repo_pass: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"Password used to authorize access to the git repository. Required when adding the project integrated with custom git repository and the provided `custom_repo_url` is the HTTPS url",
		}),
	),
	custom_repo_ssh_key_id: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description:
					"The ID of the private SSH key used to authorize access to the git repository. Required when adding the project integrated with private git server by SSH url",
			}),
	),
	created_by: z.optional(zMemberView),
	http_repository: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The HTTP repository URL",
		}),
	),
	ssh_repository: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The SSH repository URL",
		}),
	),
	default_branch: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The default branch name",
		}),
	),
	integration: z.optional(zIntegrationIdView),
	fetch_submodules: z.optional(
		z.boolean().register(z.globalRegistry, {
			description:
				"Defines whether the submodules are fetched during the runs in this project",
		}),
	),
	fetch_submodules_env_key: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"Name of the key that will be used to authorize while fetching the submodules. Required when `fetch_submodules` is set to `true`",
		}),
	),
	allow_pull_requests: z.optional(
		z.boolean().register(z.globalRegistry, {
			description:
				"Enables/disables pull requests in the project. Available only for projects synchronized with GitHub or GitHub Enterprise repository",
		}),
	),
	update_default_branch_from_external: z.optional(
		z.boolean().register(z.globalRegistry, {
			description:
				"If set to true, the default branch will be updated from GitHub/GitLab/Bitbucket.",
		}),
	),
	without_repository: z.optional(
		z.boolean().register(z.globalRegistry, {
			description:
				"If set to true, the project is created without any repository attached.",
		}),
	),
});

/**
 * The environment variables of the sandbox
 */
export const zAddVariableInObjectRequest = z
	.object({
		url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "API endpoint to GET this object",
				})
				.readonly(),
		),
		html_url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "Web URL to view this object in Buddy.works",
				})
				.readonly(),
		),
		key: z.string().register(z.globalRegistry, {
			description: "The name of the variable",
		}),
		value: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The value of the variable",
			}),
		),
		settable: z.optional(
			z.boolean().register(z.globalRegistry, {
				description:
					"If set to `true` the variable value can be set by Buddy actions",
			}),
		),
		run_only_settable: z.optional(
			z.boolean().register(z.globalRegistry, {
				description:
					"Available only if `type=VAR`. If set to `true` the variable value can be set by Buddy actions only for execution time",
			}),
		),
		encrypted: z.optional(
			z.boolean().register(z.globalRegistry, {
				description:
					"If set to `true` the variable value will be encrypted and hidden",
			}),
		),
		description: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The optional description of the variable",
			}),
		),
		init_path: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Initial path for the variable",
			}),
		),
		defaults: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Default value for the variable",
			}),
		),
		file_path: z.optional(
			z.string().register(z.globalRegistry, {
				description:
					"Specifies where to copy the file on each run. Set if `type` is `SSH_KEY`",
			}),
		),
		file_chmod: z.optional(
			z.string().register(z.globalRegistry, {
				description:
					"File permission set on copy to a container on each run. Set if `type` is `SSH_KEY`",
			}),
		),
		file_place: z.optional(
			z.enum(["NONE", "CONTAINER"]).register(z.globalRegistry, {
				description:
					"Set if `type` is `SSH_KEY`. If it's `NONE`, the variable can be used as a parameter in an action. For `CONTAINER`, the given key is additionally copied to an action container on each run",
			}),
		),
		password: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Password for certificates",
			}),
		),
		passphrase: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Passphrase for encrypted SSH keys",
			}),
		),
		key_identifier: z.optional(
			z.string().register(z.globalRegistry, {
				description: "GPG key identifier",
			}),
		),
		type: z
			.enum([
				"VAR",
				"FILE",
				"SSH_KEY",
				"IOS_KEYCHAIN",
				"IOS_PROVISION_PROFILES",
				"SSH_PUBLIC_KEY",
				"GPG_KEY",
			])
			.register(z.globalRegistry, {
				description:
					"The type of the added variable. Can be one of `VAR` or `SSH_KEY`",
			}),
	})
	.register(z.globalRegistry, {
		description: "The environment variables of the sandbox",
	});

/**
 * The TLS/SSL encryption settings of the tunnel
 */
export const zTlsSettingsView = z
	.object({
		url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "API endpoint to GET this object",
				})
				.readonly(),
		),
		html_url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "Web URL to view this object in Buddy.works",
				})
				.readonly(),
		),
		terminate_at: z.optional(
			z.enum(["REGION", "AGENT", "TARGET"]).register(z.globalRegistry, {
				description: "Where to terminate TLS connection",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "The TLS/SSL encryption settings of the tunnel",
	});

/**
 * The HTTP-specific settings of the tunnel
 */
export const zHttpSettingsView = z
	.object({
		url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "API endpoint to GET this object",
				})
				.readonly(),
		),
		html_url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "Web URL to view this object in Buddy.works",
				})
				.readonly(),
		),
		verify_certificate: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether to verify SSL/TLS certificates",
			}),
		),
		compression: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Enable HTTP compression",
			}),
		),
		http2: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Enable HTTP/2 protocol support",
			}),
		),
		log_requests: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Log incoming HTTP requests",
			}),
		),
		request_headers: z.optional(
			z.array(z.record(z.string(), z.string())).register(z.globalRegistry, {
				description: "Custom HTTP headers to add to requests",
			}),
		),
		whitelist_user_agents: z.optional(
			z.array(z.string()).register(z.globalRegistry, {
				description: "List of allowed User-Agent strings",
			}),
		),
		rewrite_host_header: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Rewrite the Host header to this value",
			}),
		),
		response_headers: z.optional(
			z.array(z.record(z.string(), z.string())).register(z.globalRegistry, {
				description: "Custom HTTP headers to add to responses",
			}),
		),
		login: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Basic authentication username",
			}),
		),
		circuit_breaker: z.optional(
			z
				.int()
				.min(-2147483648, {
					error: "Invalid value: Expected int32 to be >= -2147483648",
				})
				.max(2147483647, {
					error: "Invalid value: Expected int32 to be <= 2147483647",
				})
				.register(z.globalRegistry, {
					description: "Circuit breaker threshold (number of failed requests)",
				}),
		),
		serve_path: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Base path for serving requests",
			}),
		),
		auth_type: z.optional(
			z.enum(["NONE", "BASIC", "BUDDY"]).register(z.globalRegistry, {
				description: "Type of authentication used",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "The HTTP-specific settings of the tunnel",
	});

export const zTunnelView = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	name: z.string().register(z.globalRegistry, {
		description: "The name of the tunnel",
	}),
	endpoint: z.string().register(z.globalRegistry, {
		description: "The endpoint URL of the tunnel",
	}),
	type: z.enum(["TCP", "TLS", "HTTP", "SSH"]).register(z.globalRegistry, {
		description: "The type of the tunnel",
	}),
	region: z.enum(["US", "EU", "AS"]).register(z.globalRegistry, {
		description: "The region where the tunnel is deployed",
	}),
	whitelist: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "The IP addresses or domains allowed to access the tunnel",
		}),
	),
	timeout: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description: "The connection timeout of the tunnel in seconds",
			}),
	),
	http: z.optional(zHttpSettingsView),
	tls: z.optional(zTlsSettingsView),
	endpoint_url: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The url of the tunnel",
		}),
	),
});

export const zUpdateSandboxRequest = z.object({
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The name of the sandbox",
		}),
	),
	identifier: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
		}),
	),
	resources: z.optional(
		z
			.enum([
				"1x2",
				"2x4",
				"3x6",
				"4x8",
				"5x10",
				"6x12",
				"7x14",
				"8x16",
				"9x18",
				"10x20",
				"11x22",
				"12x24",
				"CUSTOM",
			])
			.register(z.globalRegistry, {
				description: "The resource configuration of the sandbox (CPU x RAM)",
			}),
	),
	install_commands: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The commands to run during setup of the sandbox",
		}),
	),
	run_command: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The run command of the sandbox",
		}),
	),
	app_dir: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The application directory of the sandbox",
		}),
	),
	app_type: z.optional(
		z.enum(["CMD", "SERVICE"]).register(z.globalRegistry, {
			description:
				"The application type of the sandbox (passed command or existent service eg. apache2)",
		}),
	),
	tags: z.optional(
		z
			.array(
				z.string().register(z.globalRegistry, {
					description: "The list of tags associated with the sandbox",
				}),
			)
			.register(z.globalRegistry, {
				description: "The list of tags associated with the sandbox",
			}),
	),
	endpoints: z.optional(
		z.array(zTunnelView).register(z.globalRegistry, {
			description: "The tunnel endpoints of the sandbox",
		}),
	),
	variables: z.optional(
		z.array(zAddVariableInObjectRequest).register(z.globalRegistry, {
			description: "The environment variables of the sandbox",
		}),
	),
});

export const zSandboxesView = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	sandboxes: z.optional(z.array(zSandboxIdView)),
});

/**
 * Content item in a sandbox
 */
export const zSandboxContentItem = z
	.object({
		url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "API endpoint to GET this object",
				})
				.readonly(),
		),
		html_url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "Web URL to view this object in Buddy.works",
				})
				.readonly(),
		),
		type: z.optional(
			z.enum(["FILE", "DIR"]).register(z.globalRegistry, {
				description: "The content type (FILE or DIR)",
			}),
		),
		name: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The name of the file or directory",
			}),
		),
		path: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The path to the file or directory",
			}),
		),
		size: z.optional(
			z.coerce
				.bigint()
				.min(BigInt("-9223372036854775808"), {
					error: "Invalid value: Expected int64 to be >= -9223372036854775808",
				})
				.max(BigInt("9223372036854775807"), {
					error: "Invalid value: Expected int64 to be <= 9223372036854775807",
				})
				.register(z.globalRegistry, {
					description: "The size of the file in bytes",
				}),
		),
	})
	.register(z.globalRegistry, {
		description: "Content item in a sandbox",
	});

/**
 * Sandbox content listing
 */
export const zSandboxContentView = z
	.object({
		url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "API endpoint to GET this object",
				})
				.readonly(),
		),
		html_url: z.optional(
			z
				.string()
				.register(z.globalRegistry, {
					description: "Web URL to view this object in Buddy.works",
				})
				.readonly(),
		),
		contents: z.optional(
			z.array(zSandboxContentItem).register(z.globalRegistry, {
				description: "List of content items in the directory",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Sandbox content listing",
	});

export const zSandboxCommandView = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	id: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The ID of the command",
		}),
	),
	command: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Command to execute in the sandbox",
		}),
	),
	runtime: z.optional(
		z
			.enum(["BASH", "JAVASCRIPT", "TYPESCRIPT", "PYTHON"])
			.register(z.globalRegistry, {
				description:
					"Runtime environment for command execution (default: `BASH`)",
			}),
	),
	status: z.optional(
		z.enum(["INPROGRESS", "SUCCESSFUL", "FAILED"]).register(z.globalRegistry, {
			description: "Command execution status",
		}),
	),
	exit_code: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description: "Command exit code",
			}),
	),
	logs_url: z.optional(
		z.string().register(z.globalRegistry, {
			description: "API endpoint URL to retrieve logs for this command",
		}),
	),
});

export const zSandboxCommandsView = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	commands: z.optional(z.array(zSandboxCommandView)),
});

export const zSandboxCommandLog = z.object({
	type: z.optional(
		z.enum(["STDOUT", "STDERR"]).register(z.globalRegistry, {
			description:
				"The type of command output stream. `STDOUT` for standard output, `STDERR` for error output.",
		}),
	),
	data: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The command execution logs.",
		}),
	),
});

export const zSandboxAppLogsView = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	cursor: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Cursor for pagination",
		}),
	),
	logs: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "Application log entries",
		}),
	),
});

export const zShortSnapshotView = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	id: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The ID of the snapshot",
		}),
	),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Snapshot name",
		}),
	),
	size: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description: "Snapshot size in GB",
			}),
	),
	status: z.optional(
		z
			.enum(["CREATING", "CREATED", "DELETING", "FAILED"])
			.register(z.globalRegistry, {
				description: "Snapshot status",
			}),
	),
	create_date: z.optional(
		z.iso.datetime().register(z.globalRegistry, {
			description: "Snapshot creation date",
		}),
	),
});

export const zSnapshotsView = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	snapshots: z.optional(
		z.array(zShortSnapshotView).register(z.globalRegistry, {
			description: "Collection of snapshots",
		}),
	),
});

export const zExecuteSandboxCommandRequest = z.object({
	command: z.string().register(z.globalRegistry, {
		description: "Command to execute in the sandbox",
	}),
	runtime: z.optional(
		z
			.enum(["BASH", "JAVASCRIPT", "TYPESCRIPT", "PYTHON"])
			.register(z.globalRegistry, {
				description:
					"Runtime environment for command execution (default: `BASH`)",
			}),
	),
});

export const zAddSnapshotRequest = z.object({
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Snapshot name",
		}),
	),
});

export const zSnapshotView = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	id: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The ID of the snapshot",
		}),
	),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Snapshot name",
		}),
	),
	size: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description: "Snapshot size in GB",
			}),
	),
	status: z.optional(
		z
			.enum(["CREATING", "CREATED", "DELETING", "FAILED"])
			.register(z.globalRegistry, {
				description: "Snapshot status",
			}),
	),
	create_date: z.optional(
		z.iso.datetime().register(z.globalRegistry, {
			description: "Snapshot creation date",
		}),
	),
	created_by: z.optional(zMemberView),
});

export const zSandboxYamlView = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	yaml: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The base64-encoded YAML configuration of the sandbox",
		}),
	),
});

export const zCreateNewSandboxRequest = z.object({
	name: z.string().register(z.globalRegistry, {
		description: "The name of the sandbox",
	}),
	identifier: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
		}),
	),
	os: z.string().register(z.globalRegistry, {
		description:
			'The operating system of the sandbox ["ubuntu:22.04", "ubuntu:24.04"]',
	}),
	resources: z.optional(
		z
			.enum([
				"1x2",
				"2x4",
				"3x6",
				"4x8",
				"5x10",
				"6x12",
				"7x14",
				"8x16",
				"9x18",
				"10x20",
				"11x22",
				"12x24",
				"CUSTOM",
			])
			.register(z.globalRegistry, {
				description: "The resource configuration of the sandbox (CPU x RAM)",
			}),
	),
	install_commands: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The commands to run during setup of the sandbox",
		}),
	),
	run_command: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The run command of the sandbox",
		}),
	),
	app_dir: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The application directory of the sandbox",
		}),
	),
	app_type: z.optional(
		z.enum(["CMD", "SERVICE"]).register(z.globalRegistry, {
			description:
				"The application type of the sandbox (passed command or existent service eg. apache2)",
		}),
	),
	tags: z.optional(
		z
			.array(
				z.string().register(z.globalRegistry, {
					description: "The list of tags associated with the sandbox",
				}),
			)
			.register(z.globalRegistry, {
				description: "The list of tags associated with the sandbox",
			}),
	),
	endpoints: z.optional(
		z.array(zTunnelView).register(z.globalRegistry, {
			description: "The tunnel endpoints of the sandbox",
		}),
	),
	variables: z.optional(
		z.array(zAddVariableInObjectRequest).register(z.globalRegistry, {
			description: "The environment variables of the sandbox",
		}),
	),
});

/**
 * The list of variables you can use the action
 */
export const zEnvironmentVariableView = z
	.object({
		id: z.optional(
			z
				.int()
				.min(-2147483648, {
					error: "Invalid value: Expected int32 to be >= -2147483648",
				})
				.max(2147483647, {
					error: "Invalid value: Expected int32 to be <= 2147483647",
				})
				.register(z.globalRegistry, {
					description: "The ID of the variable",
				}),
		),
		key: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The name of the variable",
			}),
		),
		value: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The value of the variable",
			}),
		),
		type: z.optional(
			z
				.enum([
					"VAR",
					"FILE",
					"SSH_KEY",
					"IOS_KEYCHAIN",
					"IOS_PROVISION_PROFILES",
					"SSH_PUBLIC_KEY",
					"GPG_KEY",
				])
				.register(z.globalRegistry, {
					description:
						"The type of the added variable. Can be one of `VAR` or `SSH_KEY`",
				}),
		),
		encrypted: z.optional(
			z.boolean().register(z.globalRegistry, {
				description:
					"If set to `true` the variable value will be encrypted and hidden",
			}),
		),
		settable: z.optional(
			z.boolean().register(z.globalRegistry, {
				description:
					"If set to `true` the variable value can be set by Buddy actions",
			}),
		),
		run_only_settable: z.optional(
			z.boolean().register(z.globalRegistry, {
				description:
					"Available only if `type=VAR`. If set to `true` the variable value can be set by Buddy actions only for execution time",
			}),
		),
		description: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The optional description of the variable",
			}),
		),
		init_path: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Initial path for the variable",
			}),
		),
		defaults: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Default value for the variable",
			}),
		),
		file_path: z.optional(
			z.string().register(z.globalRegistry, {
				description:
					"Specifies where to copy the file on each run. Set if `type` is `SSH_KEY`",
			}),
		),
		file_chmod: z.optional(
			z.string().register(z.globalRegistry, {
				description:
					"File permission set on copy to a container on each run. Set if `type` is `SSH_KEY`",
			}),
		),
		file_place: z.optional(
			z.enum(["NONE", "CONTAINER"]).register(z.globalRegistry, {
				description:
					"Set if `type` is `SSH_KEY`. If it's `NONE`, the variable can be used as a parameter in an action. For `CONTAINER`, the given key is additionally copied to an action container on each run",
			}),
		),
		binary: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether the file is binary",
			}),
		),
		public_value: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Public value for SSH key type variables",
			}),
		),
		key_fingerprint: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Fingerprint of SSH key",
			}),
		),
		checksum: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Checksum of the variable value",
			}),
		),
		password: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Password for certificates",
			}),
		),
		passphrase: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Passphrase for encrypted SSH keys",
			}),
		),
		key_identifier: z.optional(
			z.string().register(z.globalRegistry, {
				description: "GPG key identifier",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "The list of variables you can use the action",
	});

export const zCreateFromSnapshotRequest = z.object({
	snapshot_id: z.string().register(z.globalRegistry, {
		description: "The ID of the snapshot to create from",
	}),
	name: z.string().register(z.globalRegistry, {
		description: "The name of the sandbox",
	}),
	identifier: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
		}),
	),
	os: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				'The operating system of the sandbox ["ubuntu:22.04", "ubuntu:24.04"]',
		}),
	),
	resources: z.optional(
		z
			.enum([
				"1x2",
				"2x4",
				"3x6",
				"4x8",
				"5x10",
				"6x12",
				"7x14",
				"8x16",
				"9x18",
				"10x20",
				"11x22",
				"12x24",
				"CUSTOM",
			])
			.register(z.globalRegistry, {
				description: "The resource configuration of the sandbox (CPU x RAM)",
			}),
	),
	install_commands: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The commands to run during setup of the sandbox",
		}),
	),
	run_command: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The run command of the sandbox",
		}),
	),
	app_dir: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The application directory of the sandbox",
		}),
	),
	app_type: z.optional(
		z.enum(["CMD", "SERVICE"]).register(z.globalRegistry, {
			description:
				"The application type of the sandbox (passed command or existent service eg. apache2)",
		}),
	),
	tags: z.optional(
		z
			.array(
				z.string().register(z.globalRegistry, {
					description: "The list of tags associated with the sandbox",
				}),
			)
			.register(z.globalRegistry, {
				description: "The list of tags associated with the sandbox",
			}),
	),
	endpoints: z.optional(
		z.array(zTunnelView).register(z.globalRegistry, {
			description: "The tunnel endpoints of the sandbox",
		}),
	),
	variables: z.optional(
		z.array(zEnvironmentVariableView).register(z.globalRegistry, {
			description: "The environment variables of the sandbox",
		}),
	),
});

export const zCloneSandboxRequest = z.object({
	source_sandbox_id: z.string().register(z.globalRegistry, {
		description: "The ID of the sandbox to clone",
	}),
	name: z.string().register(z.globalRegistry, {
		description: "The name of the sandbox",
	}),
	identifier: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
		}),
	),
});

export const zSandboxResponse = z.object({
	url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "API endpoint to GET this object",
			})
			.readonly(),
	),
	html_url: z.optional(
		z
			.string()
			.register(z.globalRegistry, {
				description: "Web URL to view this object in Buddy.works",
			})
			.readonly(),
	),
	id: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	),
	identifier: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
		}),
	),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The name of the sandbox",
		}),
	),
	status: z.optional(
		z
			.enum([
				"STARTING",
				"STOPPING",
				"FAILED",
				"RUNNING",
				"STOPPED",
				"RESTORING",
			])
			.register(z.globalRegistry, {
				description: "The current status of the sandbox",
			}),
	),
	os: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				'The operating system of the sandbox ["ubuntu:22.04", "ubuntu:24.04"]',
		}),
	),
	resources: z.optional(
		z
			.enum([
				"1x2",
				"2x4",
				"3x6",
				"4x8",
				"5x10",
				"6x12",
				"7x14",
				"8x16",
				"9x18",
				"10x20",
				"11x22",
				"12x24",
				"CUSTOM",
			])
			.register(z.globalRegistry, {
				description: "The resource configuration of the sandbox (CPU x RAM)",
			}),
	),
	install_commands: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The commands to run during setup of the sandbox",
		}),
	),
	run_command: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The run command of the sandbox",
		}),
	),
	app_dir: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The application directory of the sandbox",
		}),
	),
	app_type: z.optional(
		z.enum(["CMD", "SERVICE"]).register(z.globalRegistry, {
			description:
				"The application type of the sandbox (passed command or existent service eg. apache2)",
		}),
	),
	tags: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "The list of tags associated with the sandbox",
		}),
	),
	app_status: z.optional(
		z.enum(["NONE", "RUNNING", "ENDED", "FAILED"]).register(z.globalRegistry, {
			description: "The current application status of the sandbox",
		}),
	),
	boot_logs: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "The boot logs of the sandbox",
		}),
	),
	setup_status: z.optional(
		z.enum(["INPROGRESS", "SUCCESS", "FAILED"]).register(z.globalRegistry, {
			description: "The current setup status of the sandbox",
		}),
	),
	endpoints: z.optional(
		z.array(zTunnelView).register(z.globalRegistry, {
			description: "The tunnel endpoints of the sandbox",
		}),
	),
	project: z.optional(zProjectView),
	variables: z.optional(
		z.array(zEnvironmentVariableView).register(z.globalRegistry, {
			description: "The environment variables of the sandbox",
		}),
	),
});

/**
 * Sandbox reference
 */
export const zSandboxIdViewWritable = z
	.object({
		id: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The ID of the sandbox",
			}),
		),
		identifier: z.optional(
			z.string().register(z.globalRegistry, {
				description:
					"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
			}),
		),
		name: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The name of the sandbox",
			}),
		),
		status: z.optional(
			z
				.enum([
					"STARTING",
					"STOPPING",
					"FAILED",
					"RUNNING",
					"STOPPED",
					"RESTORING",
				])
				.register(z.globalRegistry, {
					description: "The current status of the sandbox",
				}),
		),
	})
	.register(z.globalRegistry, {
		description: "Sandbox reference",
	});

/**
 * Integration reference
 */
export const zIntegrationIdViewWritable = z
	.object({
		identifier: z.optional(
			z.string().register(z.globalRegistry, {
				description: "A human-readable ID of the integration",
			}),
		),
		hash_id: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The unique hash ID of the integration",
			}),
		),
		name: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The name of the integration",
			}),
		),
		type: z.optional(
			z
				.enum([
					"GIT_HUB",
					"BITBUCKET",
					"GOOGLE",
					"DIGITAL_OCEAN",
					"SLACK",
					"MODULUS",
					"HEROKU",
					"AMAZON",
					"GIT_LAB",
					"SHOPIFY",
					"GIT_HUB_ENTERPRISE",
					"GIT_LAB_ENTERPRISE",
					"PUSHOVER",
					"PUSHBULLET",
					"RACKSPACE",
					"CUSTOM",
					"CLOUDFLARE",
					"NEW_RELIC",
					"SENTRY",
					"ROLLBAR",
					"DATADOG",
					"DO_SPACES",
					"HONEYBADGER",
					"VULTR",
					"SENTRY_ENTERPRISE",
					"LOGGLY",
					"HIP_CHAT",
					"FIREBASE",
					"TELEGRAM",
					"AZURE",
					"UPCLOUD",
					"GHOST_INSPECTOR",
					"NETLIFY",
					"AZURE_CLOUD",
					"MICROSOFT_TEAMS",
					"GOOGLE_SERVICE_ACCOUNT",
					"GOOGLE_PLAY_STORE",
					"DOCKER_HUB",
					"APP_STORE",
					"GIT_HUB_APP",
					"GIT_HUB_APP_ENTERPRISE",
					"GIT_HUB_API",
					"ATOP",
					"SNYK",
					"STACK_HAWK",
					"BLACKFIRE",
					"BACKBLAZE",
					"ONE_LOGIN",
					"OKTA",
					"CONTENTFUL",
				])
				.register(z.globalRegistry, {
					description: "The type of integration",
				}),
		),
		auth_type: z.optional(
			z
				.enum([
					"OAUTH",
					"TOKEN",
					"API_KEY",
					"APP",
					"APP_SPRYKER",
					"TOKEN_APP_EXTENSION",
					"DEFAULT",
					"OIDC",
					"TRUSTED",
					"APP_RW",
				])
				.register(z.globalRegistry, {
					description: "The authentication method used by the integration",
				}),
		),
		host_url: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The host URL for custom integrations",
			}),
		),
		webhook_address: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The webhook URL for receiving notifications",
			}),
		),
		atop_url: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The ATOP service URL",
			}),
		),
		app_id: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The application ID for Azure Cloud integrations",
			}),
		),
		google_project: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The Google Cloud project ID",
			}),
		),
		audience: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The JWT audience for token validation",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Integration reference",
	});

/**
 * User/member reference
 */
export const zMemberViewWritable = z
	.object({
		id: z.optional(
			z
				.int()
				.min(-2147483648, {
					error: "Invalid value: Expected int32 to be >= -2147483648",
				})
				.max(2147483647, {
					error: "Invalid value: Expected int32 to be <= 2147483647",
				})
				.register(z.globalRegistry, {
					description: "The ID of the user",
				}),
		),
		name: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The name of the user",
			}),
		),
		avatar_url: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The avatar URL of the user",
			}),
		),
		email: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The email address of the user",
			}),
		),
		admin: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether the user has admin privileges",
			}),
		),
		workspace_owner: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether the user is workspace owner",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "User/member reference",
	});

export const zProjectViewWritable = z.object({
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the project",
		}),
	),
	display_name: z.string().register(z.globalRegistry, {
		description: "The Name of the project",
	}),
	status: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The status of the project",
		}),
	),
	access: z.optional(
		z.enum(["PRIVATE", "PUBLIC"]).register(z.globalRegistry, {
			description: "Indicates if this is a public project",
		}),
	),
	create_date: z.optional(
		z.iso.datetime().register(z.globalRegistry, {
			description: "The creation date of the project",
		}),
	),
	external_project_id: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"Repo slug of the Bitbucket, GitHub or GitLab project. Required when adding the integrated project",
		}),
	),
	git_lab_project_id: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description: "ID of the project in GitLab",
			}),
	),
	custom_repo_url: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"SSH or HTTPS url of the git repository. Required when adding the project integrated with custom git repository",
		}),
	),
	custom_repo_user: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"Username used to authorize access to the git repository. Required when adding the project integrated with custom git repository",
		}),
	),
	custom_repo_pass: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"Password used to authorize access to the git repository. Required when adding the project integrated with custom git repository and the provided `custom_repo_url` is the HTTPS url",
		}),
	),
	custom_repo_ssh_key_id: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description:
					"The ID of the private SSH key used to authorize access to the git repository. Required when adding the project integrated with private git server by SSH url",
			}),
	),
	created_by: z.optional(zMemberViewWritable),
	http_repository: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The HTTP repository URL",
		}),
	),
	ssh_repository: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The SSH repository URL",
		}),
	),
	default_branch: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The default branch name",
		}),
	),
	integration: z.optional(zIntegrationIdViewWritable),
	fetch_submodules: z.optional(
		z.boolean().register(z.globalRegistry, {
			description:
				"Defines whether the submodules are fetched during the runs in this project",
		}),
	),
	fetch_submodules_env_key: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"Name of the key that will be used to authorize while fetching the submodules. Required when `fetch_submodules` is set to `true`",
		}),
	),
	allow_pull_requests: z.optional(
		z.boolean().register(z.globalRegistry, {
			description:
				"Enables/disables pull requests in the project. Available only for projects synchronized with GitHub or GitHub Enterprise repository",
		}),
	),
	update_default_branch_from_external: z.optional(
		z.boolean().register(z.globalRegistry, {
			description:
				"If set to true, the default branch will be updated from GitHub/GitLab/Bitbucket.",
		}),
	),
	without_repository: z.optional(
		z.boolean().register(z.globalRegistry, {
			description:
				"If set to true, the project is created without any repository attached.",
		}),
	),
});

/**
 * The environment variables of the sandbox
 */
export const zAddVariableInObjectRequestWritable = z
	.object({
		key: z.string().register(z.globalRegistry, {
			description: "The name of the variable",
		}),
		value: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The value of the variable",
			}),
		),
		settable: z.optional(
			z.boolean().register(z.globalRegistry, {
				description:
					"If set to `true` the variable value can be set by Buddy actions",
			}),
		),
		run_only_settable: z.optional(
			z.boolean().register(z.globalRegistry, {
				description:
					"Available only if `type=VAR`. If set to `true` the variable value can be set by Buddy actions only for execution time",
			}),
		),
		encrypted: z.optional(
			z.boolean().register(z.globalRegistry, {
				description:
					"If set to `true` the variable value will be encrypted and hidden",
			}),
		),
		description: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The optional description of the variable",
			}),
		),
		init_path: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Initial path for the variable",
			}),
		),
		defaults: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Default value for the variable",
			}),
		),
		file_path: z.optional(
			z.string().register(z.globalRegistry, {
				description:
					"Specifies where to copy the file on each run. Set if `type` is `SSH_KEY`",
			}),
		),
		file_chmod: z.optional(
			z.string().register(z.globalRegistry, {
				description:
					"File permission set on copy to a container on each run. Set if `type` is `SSH_KEY`",
			}),
		),
		file_place: z.optional(
			z.enum(["NONE", "CONTAINER"]).register(z.globalRegistry, {
				description:
					"Set if `type` is `SSH_KEY`. If it's `NONE`, the variable can be used as a parameter in an action. For `CONTAINER`, the given key is additionally copied to an action container on each run",
			}),
		),
		password: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Password for certificates",
			}),
		),
		passphrase: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Passphrase for encrypted SSH keys",
			}),
		),
		key_identifier: z.optional(
			z.string().register(z.globalRegistry, {
				description: "GPG key identifier",
			}),
		),
		type: z
			.enum([
				"VAR",
				"FILE",
				"SSH_KEY",
				"IOS_KEYCHAIN",
				"IOS_PROVISION_PROFILES",
				"SSH_PUBLIC_KEY",
				"GPG_KEY",
			])
			.register(z.globalRegistry, {
				description:
					"The type of the added variable. Can be one of `VAR` or `SSH_KEY`",
			}),
	})
	.register(z.globalRegistry, {
		description: "The environment variables of the sandbox",
	});

/**
 * The TLS/SSL encryption settings of the tunnel
 */
export const zTlsSettingsViewWritable = z
	.object({
		private_key: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Private key for TLS certificate",
			}),
		),
		certificate: z.optional(
			z.string().register(z.globalRegistry, {
				description: "TLS certificate",
			}),
		),
		ca_certificate: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Certificate Authority certificate",
			}),
		),
		terminate_at: z.optional(
			z.enum(["REGION", "AGENT", "TARGET"]).register(z.globalRegistry, {
				description: "Where to terminate TLS connection",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "The TLS/SSL encryption settings of the tunnel",
	});

/**
 * The HTTP-specific settings of the tunnel
 */
export const zHttpSettingsViewWritable = z
	.object({
		verify_certificate: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Whether to verify SSL/TLS certificates",
			}),
		),
		compression: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Enable HTTP compression",
			}),
		),
		http2: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Enable HTTP/2 protocol support",
			}),
		),
		log_requests: z.optional(
			z.boolean().register(z.globalRegistry, {
				description: "Log incoming HTTP requests",
			}),
		),
		request_headers: z.optional(
			z.array(z.record(z.string(), z.string())).register(z.globalRegistry, {
				description: "Custom HTTP headers to add to requests",
			}),
		),
		whitelist_user_agents: z.optional(
			z.array(z.string()).register(z.globalRegistry, {
				description: "List of allowed User-Agent strings",
			}),
		),
		rewrite_host_header: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Rewrite the Host header to this value",
			}),
		),
		response_headers: z.optional(
			z.array(z.record(z.string(), z.string())).register(z.globalRegistry, {
				description: "Custom HTTP headers to add to responses",
			}),
		),
		login: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Basic authentication username",
			}),
		),
		password: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Basic authentication password",
			}),
		),
		tls_ca: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Custom TLS Certificate Authority",
			}),
		),
		circuit_breaker: z.optional(
			z
				.int()
				.min(-2147483648, {
					error: "Invalid value: Expected int32 to be >= -2147483648",
				})
				.max(2147483647, {
					error: "Invalid value: Expected int32 to be <= 2147483647",
				})
				.register(z.globalRegistry, {
					description: "Circuit breaker threshold (number of failed requests)",
				}),
		),
		serve_path: z.optional(
			z.string().register(z.globalRegistry, {
				description: "Base path for serving requests",
			}),
		),
		auth_type: z.optional(
			z.enum(["NONE", "BASIC", "BUDDY"]).register(z.globalRegistry, {
				description: "Type of authentication used",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "The HTTP-specific settings of the tunnel",
	});

export const zTunnelViewWritable = z.object({
	name: z.string().register(z.globalRegistry, {
		description: "The name of the tunnel",
	}),
	endpoint: z.string().register(z.globalRegistry, {
		description: "The endpoint URL of the tunnel",
	}),
	type: z.enum(["TCP", "TLS", "HTTP", "SSH"]).register(z.globalRegistry, {
		description: "The type of the tunnel",
	}),
	region: z.enum(["US", "EU", "AS"]).register(z.globalRegistry, {
		description: "The region where the tunnel is deployed",
	}),
	whitelist: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "The IP addresses or domains allowed to access the tunnel",
		}),
	),
	timeout: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description: "The connection timeout of the tunnel in seconds",
			}),
	),
	http: z.optional(zHttpSettingsViewWritable),
	tls: z.optional(zTlsSettingsViewWritable),
	endpoint_url: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The url of the tunnel",
		}),
	),
});

export const zUpdateSandboxRequestWritable = z.object({
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The name of the sandbox",
		}),
	),
	identifier: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
		}),
	),
	resources: z.optional(
		z
			.enum([
				"1x2",
				"2x4",
				"3x6",
				"4x8",
				"5x10",
				"6x12",
				"7x14",
				"8x16",
				"9x18",
				"10x20",
				"11x22",
				"12x24",
				"CUSTOM",
			])
			.register(z.globalRegistry, {
				description: "The resource configuration of the sandbox (CPU x RAM)",
			}),
	),
	install_commands: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The commands to run during setup of the sandbox",
		}),
	),
	run_command: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The run command of the sandbox",
		}),
	),
	app_dir: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The application directory of the sandbox",
		}),
	),
	app_type: z.optional(
		z.enum(["CMD", "SERVICE"]).register(z.globalRegistry, {
			description:
				"The application type of the sandbox (passed command or existent service eg. apache2)",
		}),
	),
	tags: z.optional(
		z
			.array(
				z.string().register(z.globalRegistry, {
					description: "The list of tags associated with the sandbox",
				}),
			)
			.register(z.globalRegistry, {
				description: "The list of tags associated with the sandbox",
			}),
	),
	endpoints: z.optional(
		z.array(zTunnelViewWritable).register(z.globalRegistry, {
			description: "The tunnel endpoints of the sandbox",
		}),
	),
	variables: z.optional(
		z.array(zAddVariableInObjectRequestWritable).register(z.globalRegistry, {
			description: "The environment variables of the sandbox",
		}),
	),
});

export const zSandboxesViewWritable = z.object({
	sandboxes: z.optional(z.array(zSandboxIdViewWritable)),
});

/**
 * Content item in a sandbox
 */
export const zSandboxContentItemWritable = z
	.object({
		type: z.optional(
			z.enum(["FILE", "DIR"]).register(z.globalRegistry, {
				description: "The content type (FILE or DIR)",
			}),
		),
		name: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The name of the file or directory",
			}),
		),
		path: z.optional(
			z.string().register(z.globalRegistry, {
				description: "The path to the file or directory",
			}),
		),
		size: z.optional(
			z.coerce
				.bigint()
				.min(BigInt("-9223372036854775808"), {
					error: "Invalid value: Expected int64 to be >= -9223372036854775808",
				})
				.max(BigInt("9223372036854775807"), {
					error: "Invalid value: Expected int64 to be <= 9223372036854775807",
				})
				.register(z.globalRegistry, {
					description: "The size of the file in bytes",
				}),
		),
	})
	.register(z.globalRegistry, {
		description: "Content item in a sandbox",
	});

/**
 * Sandbox content listing
 */
export const zSandboxContentViewWritable = z
	.object({
		contents: z.optional(
			z.array(zSandboxContentItemWritable).register(z.globalRegistry, {
				description: "List of content items in the directory",
			}),
		),
	})
	.register(z.globalRegistry, {
		description: "Sandbox content listing",
	});

export const zSandboxCommandViewWritable = z.object({
	id: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The ID of the command",
		}),
	),
	command: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Command to execute in the sandbox",
		}),
	),
	runtime: z.optional(
		z
			.enum(["BASH", "JAVASCRIPT", "TYPESCRIPT", "PYTHON"])
			.register(z.globalRegistry, {
				description:
					"Runtime environment for command execution (default: `BASH`)",
			}),
	),
	status: z.optional(
		z.enum(["INPROGRESS", "SUCCESSFUL", "FAILED"]).register(z.globalRegistry, {
			description: "Command execution status",
		}),
	),
	exit_code: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description: "Command exit code",
			}),
	),
	logs_url: z.optional(
		z.string().register(z.globalRegistry, {
			description: "API endpoint URL to retrieve logs for this command",
		}),
	),
});

export const zSandboxCommandsViewWritable = z.object({
	commands: z.optional(z.array(zSandboxCommandViewWritable)),
});

export const zSandboxAppLogsViewWritable = z.object({
	cursor: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Cursor for pagination",
		}),
	),
	logs: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "Application log entries",
		}),
	),
});

export const zShortSnapshotViewWritable = z.object({
	id: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The ID of the snapshot",
		}),
	),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Snapshot name",
		}),
	),
	size: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description: "Snapshot size in GB",
			}),
	),
	status: z.optional(
		z
			.enum(["CREATING", "CREATED", "DELETING", "FAILED"])
			.register(z.globalRegistry, {
				description: "Snapshot status",
			}),
	),
	create_date: z.optional(
		z.iso.datetime().register(z.globalRegistry, {
			description: "Snapshot creation date",
		}),
	),
});

export const zSnapshotsViewWritable = z.object({
	snapshots: z.optional(
		z.array(zShortSnapshotViewWritable).register(z.globalRegistry, {
			description: "Collection of snapshots",
		}),
	),
});

export const zSnapshotViewWritable = z.object({
	id: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The ID of the snapshot",
		}),
	),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "Snapshot name",
		}),
	),
	size: z.optional(
		z
			.int()
			.min(-2147483648, {
				error: "Invalid value: Expected int32 to be >= -2147483648",
			})
			.max(2147483647, {
				error: "Invalid value: Expected int32 to be <= 2147483647",
			})
			.register(z.globalRegistry, {
				description: "Snapshot size in GB",
			}),
	),
	status: z.optional(
		z
			.enum(["CREATING", "CREATED", "DELETING", "FAILED"])
			.register(z.globalRegistry, {
				description: "Snapshot status",
			}),
	),
	create_date: z.optional(
		z.iso.datetime().register(z.globalRegistry, {
			description: "Snapshot creation date",
		}),
	),
	created_by: z.optional(zMemberViewWritable),
});

export const zSandboxYamlViewWritable = z.object({
	yaml: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The base64-encoded YAML configuration of the sandbox",
		}),
	),
});

export const zCreateNewSandboxRequestWritable = z.object({
	name: z.string().register(z.globalRegistry, {
		description: "The name of the sandbox",
	}),
	identifier: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
		}),
	),
	os: z.string().register(z.globalRegistry, {
		description:
			'The operating system of the sandbox ["ubuntu:22.04", "ubuntu:24.04"]',
	}),
	resources: z.optional(
		z
			.enum([
				"1x2",
				"2x4",
				"3x6",
				"4x8",
				"5x10",
				"6x12",
				"7x14",
				"8x16",
				"9x18",
				"10x20",
				"11x22",
				"12x24",
				"CUSTOM",
			])
			.register(z.globalRegistry, {
				description: "The resource configuration of the sandbox (CPU x RAM)",
			}),
	),
	install_commands: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The commands to run during setup of the sandbox",
		}),
	),
	run_command: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The run command of the sandbox",
		}),
	),
	app_dir: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The application directory of the sandbox",
		}),
	),
	app_type: z.optional(
		z.enum(["CMD", "SERVICE"]).register(z.globalRegistry, {
			description:
				"The application type of the sandbox (passed command or existent service eg. apache2)",
		}),
	),
	tags: z.optional(
		z
			.array(
				z.string().register(z.globalRegistry, {
					description: "The list of tags associated with the sandbox",
				}),
			)
			.register(z.globalRegistry, {
				description: "The list of tags associated with the sandbox",
			}),
	),
	endpoints: z.optional(
		z.array(zTunnelViewWritable).register(z.globalRegistry, {
			description: "The tunnel endpoints of the sandbox",
		}),
	),
	variables: z.optional(
		z.array(zAddVariableInObjectRequestWritable).register(z.globalRegistry, {
			description: "The environment variables of the sandbox",
		}),
	),
});

export const zCreateFromSnapshotRequestWritable = z.object({
	snapshot_id: z.string().register(z.globalRegistry, {
		description: "The ID of the snapshot to create from",
	}),
	name: z.string().register(z.globalRegistry, {
		description: "The name of the sandbox",
	}),
	identifier: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
		}),
	),
	os: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				'The operating system of the sandbox ["ubuntu:22.04", "ubuntu:24.04"]',
		}),
	),
	resources: z.optional(
		z
			.enum([
				"1x2",
				"2x4",
				"3x6",
				"4x8",
				"5x10",
				"6x12",
				"7x14",
				"8x16",
				"9x18",
				"10x20",
				"11x22",
				"12x24",
				"CUSTOM",
			])
			.register(z.globalRegistry, {
				description: "The resource configuration of the sandbox (CPU x RAM)",
			}),
	),
	install_commands: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The commands to run during setup of the sandbox",
		}),
	),
	run_command: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The run command of the sandbox",
		}),
	),
	app_dir: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The application directory of the sandbox",
		}),
	),
	app_type: z.optional(
		z.enum(["CMD", "SERVICE"]).register(z.globalRegistry, {
			description:
				"The application type of the sandbox (passed command or existent service eg. apache2)",
		}),
	),
	tags: z.optional(
		z
			.array(
				z.string().register(z.globalRegistry, {
					description: "The list of tags associated with the sandbox",
				}),
			)
			.register(z.globalRegistry, {
				description: "The list of tags associated with the sandbox",
			}),
	),
	endpoints: z.optional(
		z.array(zTunnelViewWritable).register(z.globalRegistry, {
			description: "The tunnel endpoints of the sandbox",
		}),
	),
	variables: z.optional(
		z.array(zEnvironmentVariableView).register(z.globalRegistry, {
			description: "The environment variables of the sandbox",
		}),
	),
});

export const zSandboxResponseWritable = z.object({
	id: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	),
	identifier: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				"A human-readable ID. Alphanumeric characters, underscores, and hyphens (hyphens cannot appear at the start or end).",
		}),
	),
	name: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The name of the sandbox",
		}),
	),
	status: z.optional(
		z
			.enum([
				"STARTING",
				"STOPPING",
				"FAILED",
				"RUNNING",
				"STOPPED",
				"RESTORING",
			])
			.register(z.globalRegistry, {
				description: "The current status of the sandbox",
			}),
	),
	os: z.optional(
		z.string().register(z.globalRegistry, {
			description:
				'The operating system of the sandbox ["ubuntu:22.04", "ubuntu:24.04"]',
		}),
	),
	resources: z.optional(
		z
			.enum([
				"1x2",
				"2x4",
				"3x6",
				"4x8",
				"5x10",
				"6x12",
				"7x14",
				"8x16",
				"9x18",
				"10x20",
				"11x22",
				"12x24",
				"CUSTOM",
			])
			.register(z.globalRegistry, {
				description: "The resource configuration of the sandbox (CPU x RAM)",
			}),
	),
	install_commands: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The commands to run during setup of the sandbox",
		}),
	),
	run_command: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The run command of the sandbox",
		}),
	),
	app_dir: z.optional(
		z.string().register(z.globalRegistry, {
			description: "The application directory of the sandbox",
		}),
	),
	app_type: z.optional(
		z.enum(["CMD", "SERVICE"]).register(z.globalRegistry, {
			description:
				"The application type of the sandbox (passed command or existent service eg. apache2)",
		}),
	),
	tags: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "The list of tags associated with the sandbox",
		}),
	),
	app_status: z.optional(
		z.enum(["NONE", "RUNNING", "ENDED", "FAILED"]).register(z.globalRegistry, {
			description: "The current application status of the sandbox",
		}),
	),
	boot_logs: z.optional(
		z.array(z.string()).register(z.globalRegistry, {
			description: "The boot logs of the sandbox",
		}),
	),
	setup_status: z.optional(
		z.enum(["INPROGRESS", "SUCCESS", "FAILED"]).register(z.globalRegistry, {
			description: "The current setup status of the sandbox",
		}),
	),
	endpoints: z.optional(
		z.array(zTunnelViewWritable).register(z.globalRegistry, {
			description: "The tunnel endpoints of the sandbox",
		}),
	),
	project: z.optional(zProjectViewWritable),
	variables: z.optional(
		z.array(zEnvironmentVariableView).register(z.globalRegistry, {
			description: "The environment variables of the sandbox",
		}),
	),
});

export const zGetSandboxesData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
	}),
	query: z.object({
		project_name: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the project to filter sandboxes",
		}),
	}),
});

export const zGetSandboxesResponse = zSandboxesView;

export const zAddSandboxData = z.object({
	body: z.optional(
		z.union([
			zCloneSandboxRequest,
			zCreateFromSnapshotRequestWritable,
			zCreateNewSandboxRequestWritable,
		]),
	),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
	}),
	query: z.object({
		project_name: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the project to filter sandboxes",
		}),
	}),
});

export const zAddSandboxResponse = zSandboxResponse;

export const zDeleteSandboxData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

/**
 * Sandbox deleted successfully
 */
export const zDeleteSandboxResponse = z.void().register(z.globalRegistry, {
	description: "Sandbox deleted successfully",
});

export const zGetSandboxData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zGetSandboxResponse = zSandboxResponse;

export const zUpdateSandboxData = z.object({
	body: z.optional(zUpdateSandboxRequestWritable),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zUpdateSandboxResponse = zSandboxResponse;

export const zGetSandboxAppLogsData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(
		z.object({
			cursor: z.optional(
				z.string().register(z.globalRegistry, {
					description: "Cursor for pagination",
				}),
			),
		}),
	),
});

export const zGetSandboxAppLogsResponse = zSandboxAppLogsView;

export const zGetSandboxCommandsData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zGetSandboxCommandsResponse = zSandboxCommandsView;

export const zExecuteSandboxCommandData = z.object({
	body: z.optional(zExecuteSandboxCommandRequest),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zExecuteSandboxCommandResponse = zSandboxCommandView;

export const zGetSandboxCommandData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
		id: z.string().register(z.globalRegistry, {
			description: "The ID of the command",
		}),
	}),
	query: z.optional(z.never()),
});

export const zGetSandboxCommandResponse = zSandboxCommandView;

export const zGetSandboxCommandLogsData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
		command_id: z.string().register(z.globalRegistry, {
			description: "The ID of the command",
		}),
	}),
	query: z.optional(
		z.object({
			follow: z.optional(
				z.boolean().register(z.globalRegistry, {
					description: "If true, streams logs until the command completes",
				}),
			),
		}),
	),
});

export const zGetSandboxCommandLogsResponse = zSandboxCommandLog;

export const zTerminateSandboxCommandData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
		command_id: z.string().register(z.globalRegistry, {
			description: "The ID of the command",
		}),
	}),
	query: z.optional(z.never()),
});

export const zTerminateSandboxCommandResponse = zSandboxCommandView;

export const zDeleteSandboxFileData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
		path: z.string().regex(/.*/).register(z.globalRegistry, {
			description: "Absolute path to the file or directory to delete",
		}),
	}),
	query: z.optional(z.never()),
});

/**
 * File or directory deleted successfully
 */
export const zDeleteSandboxFileResponse = z.void().register(z.globalRegistry, {
	description: "File or directory deleted successfully",
});

export const zGetSandboxContentData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
		path: z.string().regex(/.*/).register(z.globalRegistry, {
			description:
				"Absolute path to the file or directory. Recommended directory is `/buddy`",
		}),
	}),
	query: z.optional(z.never()),
});

/**
 * Content retrieved successfully
 */
export const zGetSandboxContentResponse = zSandboxContentView;

export const zCreateSandboxDirectoryData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
		path: z.string().regex(/.*/).register(z.globalRegistry, {
			description: "Absolute path where the directory should be created",
		}),
	}),
	query: z.optional(z.never()),
});

/**
 * Directory created successfully
 */
export const zCreateSandboxDirectoryResponse = zSandboxContentItem;

export const zUploadSandboxFileData = z.object({
	body: z.optional(
		z.string().register(z.globalRegistry, {
			description: "File to upload",
		}),
	),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
		path: z.string().regex(/.*/).register(z.globalRegistry, {
			description:
				"Absolute path where the file should be uploaded. Recommended directory is `/buddy`",
		}),
	}),
	query: z.optional(z.never()),
});

/**
 * File uploaded successfully
 */
export const zUploadSandboxFileResponse = zSandboxContentItem;

export const zDownloadSandboxContentData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
		path: z.string().regex(/.*/).register(z.globalRegistry, {
			description: "Absolute path to the file or directory to download",
		}),
	}),
	query: z.optional(z.never()),
});

/**
 * Content downloaded successfully
 */
export const zDownloadSandboxContentResponse = zResponse;

export const zRestartSandboxData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zRestartSandboxResponse = zSandboxResponse;

export const zGetSandboxSnapshotsData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zGetSandboxSnapshotsResponse = zSnapshotsView;

export const zAddSandboxSnapshotData = z.object({
	body: z.optional(zAddSnapshotRequest),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zAddSandboxSnapshotResponse = zSnapshotView;

export const zDeleteSandboxSnapshotData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
		id: z.string().register(z.globalRegistry, {
			description: "The ID of the snapshot",
		}),
	}),
	query: z.optional(z.never()),
});

/**
 * Sandbox snapshot deleted successfully
 */
export const zDeleteSandboxSnapshotResponse = z
	.void()
	.register(z.globalRegistry, {
		description: "Sandbox snapshot deleted successfully",
	});

export const zGetSandboxSnapshotData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
		id: z.string().register(z.globalRegistry, {
			description: "The ID of the snapshot",
		}),
	}),
	query: z.optional(z.never()),
});

export const zGetSandboxSnapshotResponse = zSnapshotView;

export const zStartSandboxData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zStartSandboxResponse = zSandboxResponse;

export const zStopSandboxData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zStopSandboxResponse = zSandboxResponse;

export const zGetSandboxYamlData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zGetSandboxYamlResponse = zSandboxYamlView;

export const zUpdateSandboxByYamlData = z.object({
	body: z.optional(zSandboxYamlViewWritable),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		sandbox_id: z.string().register(z.globalRegistry, {
			description: "The ID of the sandbox",
		}),
	}),
	query: z.optional(z.never()),
});

export const zUpdateSandboxByYamlResponse = zSandboxResponse;

export const zGetProjectSnapshotsData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
	}),
	query: z.object({
		project_name: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the project to filter sandboxes",
		}),
	}),
});

export const zGetProjectSnapshotsResponse = zSnapshotsView;

export const zDeleteSnapshotData = z.object({
	body: z.optional(z.never()),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
		id: z.string().register(z.globalRegistry, {
			description: "The ID of the snapshot",
		}),
	}),
	query: z.optional(z.never()),
});

/**
 * Sandbox snapshot deleted successfully
 */
export const zDeleteSnapshotResponse = z.void().register(z.globalRegistry, {
	description: "Sandbox snapshot deleted successfully",
});

export const zAddSandboxByYamlData = z.object({
	body: z.optional(zSandboxYamlViewWritable),
	path: z.object({
		workspace_domain: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the workspace",
		}),
	}),
	query: z.object({
		project_name: z.string().register(z.globalRegistry, {
			description: "The human-readable ID of the project to filter sandboxes",
		}),
	}),
});

export const zAddSandboxByYamlResponse = zSandboxResponse;
