#!/usr/bin/env tsx

import { execSync } from "node:child_process";
import * as fs from "node:fs";
import * as path from "node:path";
import ts from "typescript";
import { createAuxiliaryTypeStore, zodToTs } from "zod-to-ts";
import * as schemas from "../src/api/schemas/sandbox-rest-api.gen.js";

const outputPath = path.join(process.cwd(), "src/api/schemas/types.gen.ts");

// Generate TypeScript types from Zod schemas
const typeDefinitions: string[] = [
	"/**",
	" * Generated TypeScript types from Zod schemas",
	" * DO NOT EDIT MANUALLY - Generated by scripts/generate-jsdoc-types.ts",
	" */",
	"",
];

const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
const sourceFile = ts.createSourceFile(
	"types.gen.ts",
	"",
	ts.ScriptTarget.Latest,
	false,
	ts.ScriptKind.TS,
);

// Helper to convert camelCase to IPascalCase
function toInterfaceName(name: string): string {
	// Capitalize first letter and add "I" prefix
	return `IOpenApi${name.charAt(0).toUpperCase()}${name.slice(1)}`;
}

// Create auxiliary type store for nested types
const auxiliaryTypeStore = createAuxiliaryTypeStore();

// Convert each schema to TypeScript type
for (const [name, schema] of Object.entries(schemas)) {
	if (typeof schema === "object" && schema !== null && "_def" in schema) {
		try {
			const { node } = zodToTs(schema, {
				auxiliaryTypeStore,
				unrepresentable: "any",
				io: "output",
			});
			const typeString = printer.printNode(
				ts.EmitHint.Unspecified,
				node,
				sourceFile,
			);
			const typeName = toInterfaceName(name);
			typeDefinitions.push(`export type ${typeName} = ${typeString};`);
			typeDefinitions.push("");
		} catch (error) {
			console.warn(`Failed to convert schema ${name}:`, error);
		}
	}
}

fs.writeFileSync(outputPath, typeDefinitions.join("\n"), "utf-8");
console.log(`âœ“ Generated TypeScript types at ${outputPath}`);

// Format the generated file with biome
execSync(`biome format --write ${outputPath}`, { stdio: "inherit" });
